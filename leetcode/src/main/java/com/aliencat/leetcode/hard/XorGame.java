package com.aliencat.leetcode.hard;

/**
 * 810. 黑板异或游戏
 * 黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，
 * 剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。
 * (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）
 * 并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。
 * 假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。
 * 示例：
 * 输入: nums = [1, 1, 2]
 * 输出: false
 * 解释:
 * Alice 有两个选择: 擦掉数字 1 或 2。
 * 如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，
 * 因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
 * 如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
 * 提示：
 * 1 <= N <= 1000
 * 0 <= nums[i] <= 2^16
 */
public class XorGame {


    /**
     * 分析：
     * 定义 xor = num[0] ^ nums[1] ^...^ nums[n - 1]
     * 1、xor == 0: 先手直接取胜
     * <p>
     * 2、 xor != 0 时，若nums数组为偶数数组,即nums.length为偶数
     * 若去掉元素nums[i]后的异或值记为 Si = xor ^ nums[i], i = 0, 1,.., n - 1
     * (任意数异或它本事等于0，任意数异或0等于它本身)
     * 反证法：假设对于所有的 Si==0，则必有S0^S1^...^Sn-1 = 0 (n个0异或为0)
     * 但是S0^S1^...Sn-1 = (xor ^ nums[0]) ^ (xor ^ nums[1]) ^...^(xor ^ nums[n - 1])
     * = (xor ^ xor ^...^ xor) [n个xor] ^ (nums[0] ^ nums[1]^ ... ^nums[n - 1])
     * = xor ^ xor ^...^ xor [n+1(奇数)个xor]
     * = xor != 0 与原假设矛盾
     * 所以此时每次先手必存在Si != 0 此时先手选择擦除nums[i]即可保证此轮不输，后续先手数组仍为偶数数组，必胜
     * <p>
     * 3、xor != 0 时，若nums数组为奇数数组,即nums.length为奇数
     * 同理可得 S0^S1^...Sn-1 = xor ^ xor ^...^ xor [注：n+1(偶数)个xor] = 0
     * 原假设成立，则对于所有 Si，有Si == 0，此时先手擦除任何nums[i]均会输，必输
     * <p>
     * 综上：对于先手而言，初始xor为0,或初始数组为偶数数组时必胜；初始xor不为0时且初始数组为奇数数组时必输
     */
    public boolean xorGame(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        if (xor == 0) {
            return true; //某个玩家先手时，当前黑板上所有数字按位异或运算结果等于 0，则此玩家直接获胜。
        }
        return (nums.length & 1) == 0;
    }
}
